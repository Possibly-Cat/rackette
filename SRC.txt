Task 1)
	The first situation marks an impresive combination of simultaneous accessibility, usability, and inclusion problems. THe first because people with mobility issues regarding to their hands (myself included) may essentially find it impossible to hold the keys down simultaneously. I for one, can't do it without fairly significant pain. This accessability issue causes an inclusion issue because some peoply simply can't use certain features of the program. Finally, it represents a useability issue because having to hold down awkward key shortcuts just sucks for everyone.
	The second situation showcases an effort to fix an issue that caused a usability and inclusion problem. The use of ASCII caused an inclusion problem by straight up not having characters some people might want to use in names, words, etc, and caused a usability problem by, again, not having characters some people would want to use. Unicode is a vastly more robust standard for representing characters which goes a long way to resolve these issues.

Task 2)
	1. One thing that is important to me is having languages which are not concrened with indentation or line breaks. When working on small screens where I can't fit whole lines of code neatly in frame, I've been constantly frustrated by indenting things to the wrong level or having to scroll to find where one block ends and another begins.  
	2. Generally, the systems to avoid this issue are already fairly common. Entirely parentheses/brackets/curly braces dependent languages are common and go a long way to helping with this. Another very useful aid is auto-formatting systems -- like we have on reasonml -- which are super useful with avoiding spending time frustratingly lining up vertical lines.
	3. A big problem with speech to text systems is that it's simply arduous to write out the complex syntax of a typical language. Consider trying to speak the racket comand (cons 5 (cons 4 (Cons 3 empty))). It's fairly simple to write this but would take vastly longer to speak out "open parentheses, 5, open parentheses, 4, ...". The only solution I can think of might be to use a block based system -- like scratch -- but I generally consider those as having problems of their own as compared to a typical language. Text to speech has a similair problem in that the visual distinctions made clear by things seperated by, say, parentheses would be lost in a stream of "close parenthesis, close parenthesis, ...". Here, again, the block language idea seems useful but doesn't fully solve the problem. Perhaps a programming structure focusing on performing tasks sequentialy would be useful but this might be difficult to implement and might be less capable than a typical language.
