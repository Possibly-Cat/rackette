// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$Rackette = require("./Read.bs.js");
var CS17SetupRackette$Rackette = require("./CS17SetupRackette.bs.js");

function add(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for add");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in add");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for add");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in add");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for add");
    } else {
      return Pervasives.failwith("non-number arguments in add");
    }
  } else {
    return {
            TAG: /* NumV */0,
            _0: _hd._0 + tl._0 | 0
          };
  }
}

function subtract(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for subtract");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in subtract");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for subtract");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in subtract");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for subtract");
    } else {
      return Pervasives.failwith("non-number arguments in subtract");
    }
  } else {
    return {
            TAG: /* NumV */0,
            _0: _hd._0 - tl._0 | 0
          };
  }
}

function multiply(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for multiply");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in multiply");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for multiply");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in multiply");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for multiply");
    } else {
      return Pervasives.failwith("non-number arguments in multiply");
    }
  } else {
    return {
            TAG: /* NumV */0,
            _0: Math.imul(_hd._0, tl._0)
          };
  }
}

function divide(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for divide");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in divide");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for divide");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in divide");
  }
  var tl$1 = tl._0;
  if (tl$1 === 0 && !match.tl) {
    return Pervasives.failwith("Divide by zero error");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for divide");
    } else {
      return Pervasives.failwith("non-number arguments in divide");
    }
  } else {
    return {
            TAG: /* NumV */0,
            _0: Caml_int32.div(_hd._0, tl$1)
          };
  }
}

function modulo(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for remainder");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in remainder");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for remainder");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in remainder");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for remainder");
    } else {
      return Pervasives.failwith("non-number arguments in remainder");
    }
  } else {
    return {
            TAG: /* NumV */0,
            _0: Caml_int32.mod_(_hd._0, tl._0)
          };
  }
}

function equalityq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for equalityq");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in equalityq");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for equalityq");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in equalityq");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for equalityq");
    } else {
      return Pervasives.failwith("non-number arguments in equalityq");
    }
  } else {
    return {
            TAG: /* BoolV */1,
            _0: _hd._0 === tl._0
          };
  }
}

function lessThanq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for less than");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in less than");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for less than");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in less than");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for less than");
    } else {
      return Pervasives.failwith("non-number arguments in less than");
    }
  } else {
    return {
            TAG: /* BoolV */1,
            _0: _hd._0 < tl._0
          };
  }
}

function greaterThanq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for greater than");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in greater than");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for greater than");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in greater than");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for greater than");
    } else {
      return Pervasives.failwith("non-number arguments in greater than");
    }
  } else {
    return {
            TAG: /* BoolV */1,
            _0: _hd._0 > tl._0
          };
  }
}

function leqq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for <=");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in <=");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for <=");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in <=");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for <=");
    } else {
      return Pervasives.failwith("non-number arguments in <=");
    }
  } else {
    return {
            TAG: /* BoolV */1,
            _0: _hd._0 <= tl._0
          };
  }
}

function geqq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for >=");
  }
  var _hd = alov.hd;
  if (_hd.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in >=");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for >=");
  }
  var tl = match.hd;
  if (tl.TAG !== /* NumV */0) {
    return Pervasives.failwith("non-number arguments in >=");
  }
  var match$1 = match.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      return Pervasives.failwith("too many arguments for >=");
    } else {
      return Pervasives.failwith("non-number arguments in >=");
    }
  } else {
    return {
            TAG: /* BoolV */1,
            _0: _hd._0 >= tl._0
          };
  }
}

function equalq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for equal");
  }
  var _val = alov.hd;
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for equal");
  }
  if (match.tl) {
    return Pervasives.failwith("too many arguments for equal");
  }
  switch (_val.TAG | 0) {
    case /* NumV */0 :
        var tl = alov.tl.hd;
        if (tl.TAG === /* NumV */0) {
          return {
                  TAG: /* BoolV */1,
                  _0: _val._0 === tl._0
                };
        } else {
          return Pervasives.failwith("non-number arguments in equal");
        }
    case /* BoolV */1 :
        var tl$1 = alov.tl.hd;
        if (tl$1.TAG === /* BoolV */1) {
          return {
                  TAG: /* BoolV */1,
                  _0: _val._0 === tl$1._0
                };
        } else {
          return Pervasives.failwith("non-number arguments in equal");
        }
    case /* ListV */2 :
        var tl$2 = alov.tl.hd;
        if (tl$2.TAG === /* ListV */2) {
          return {
                  TAG: /* BoolV */1,
                  _0: Caml_obj.caml_equal(_val._0, tl$2._0)
                };
        } else {
          return Pervasives.failwith("non-number arguments in equal");
        }
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        return Pervasives.failwith("non-number arguments in equal");
    
  }
}

function numberq(alov) {
  if (alov) {
    if (alov.hd.TAG === /* NumV */0) {
      if (alov.tl) {
        if (alov.tl) {
          return Pervasives.failwith("too many arguments for number?");
        } else {
          return {
                  TAG: /* BoolV */1,
                  _0: false
                };
        }
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (alov.tl) {
      return Pervasives.failwith("too many arguments for number?");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("too few arguments for number?");
  }
}

function zeroq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for zero?");
  }
  var hd = alov.hd;
  if (hd.TAG === /* NumV */0 && !alov.tl) {
    return {
            TAG: /* BoolV */1,
            _0: hd._0 === 0
          };
  }
  if (alov.tl) {
    return Pervasives.failwith("too many arguments for zero?");
  } else {
    return Pervasives.failwith("non-number argument for zero?");
  }
}

function cons(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for cons");
  }
  var match = alov.tl;
  if (!match) {
    return Pervasives.failwith("too few arguments for cons");
  }
  var myList = match.hd;
  if (myList.TAG === /* ListV */2 && !match.tl) {
    return {
            TAG: /* ListV */2,
            _0: {
              hd: alov.hd,
              tl: myList._0
            }
          };
  }
  if (match.tl) {
    return Pervasives.failwith("too many arguments for cons");
  } else {
    return Pervasives.failwith("improper arguments for cons");
  }
}

function first(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for first");
  }
  var myList = alov.hd;
  if (myList.TAG === /* ListV */2 && !alov.tl) {
    var myList$1 = myList._0;
    if (myList$1) {
      return myList$1.hd;
    } else {
      return Pervasives.failwith("Called first on empty list");
    }
  }
  if (alov.tl) {
    return Pervasives.failwith("too many arguments for first");
  } else {
    return Pervasives.failwith("non list argument in first");
  }
}

function rest(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for rest");
  }
  var myList = alov.hd;
  if (myList.TAG === /* ListV */2 && !alov.tl) {
    var myList$1 = myList._0;
    if (!myList$1) {
      return Pervasives.failwith("Called rest on empty list");
    }
    var tl = myList$1.tl;
    if (tl) {
      return {
              TAG: /* ListV */2,
              _0: tl
            };
    } else {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
  }
  if (alov.tl) {
    return Pervasives.failwith("too many arguments for rest");
  } else {
    return Pervasives.failwith("non list argument in rest");
  }
}

function emptyq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for empty?");
  }
  var myList = alov.hd;
  if (myList.TAG === /* ListV */2 && !alov.tl) {
    if (myList._0) {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  }
  if (alov.tl) {
    return Pervasives.failwith("too many arguments for empty?");
  } else {
    return Pervasives.failwith("non list argument in empty?");
  }
}

function consq(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for cons?");
  }
  var myList = alov.hd;
  if (myList.TAG === /* ListV */2 && !alov.tl) {
    if (myList._0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  }
  if (alov.tl) {
    return Pervasives.failwith("too many arguments for cons?");
  } else {
    return Pervasives.failwith("non list argument in cons?");
  }
}

function not_(alov) {
  if (!alov) {
    return Pervasives.failwith("too few arguments for not");
  }
  var myBool = alov.hd;
  if (myBool.TAG === /* BoolV */1 && !alov.tl) {
    return {
            TAG: /* BoolV */1,
            _0: !myBool._0
          };
  }
  if (alov.tl) {
    return Pervasives.failwith("too many arguments for not");
  } else {
    return Pervasives.failwith("non bool argument in not");
  }
}

var initialTle_0 = {
  hd: [
    /* Name */{
      _0: "+"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        printedRep: "builtin+",
        bProc: add
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "-"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          printedRep: "builtin-",
          bProc: subtract
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "*"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            printedRep: "builtin*",
            bProc: multiply
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "/"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              printedRep: "builtin/",
              bProc: divide
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "remainder"
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                printedRep: "builtinRemainder",
                bProc: modulo
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "="
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  printedRep: "builtin=",
                  bProc: equalityq
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: "<"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    printedRep: "builtin<",
                    bProc: lessThanq
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: ">"
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      printedRep: "builtin>",
                      bProc: greaterThanq
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: "<="
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        printedRep: "builtin<=",
                        bProc: leqq
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: ">="
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          printedRep: "builtin>=",
                          bProc: geqq
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "equal?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            printedRep: "builtinEqual?",
                            bProc: equalq
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "number?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              printedRep: "builtinNumber?",
                              bProc: numberq
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "zero?"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                printedRep: "builtinZero?",
                                bProc: zeroq
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "cons"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  printedRep: "builtinCons",
                                  bProc: cons
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "first"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    printedRep: "builtinFirst",
                                    bProc: first
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "rest"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      printedRep: "builtinRest",
                                      bProc: rest
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "empty?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        printedRep: "builtinEmpty?",
                                        bProc: emptyq
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "cons?"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          printedRep: "builtinCons?",
                                          bProc: consq
                                        }
                                      }
                                    ],
                                    tl: {
                                      hd: [
                                        /* Name */{
                                          _0: "not"
                                        },
                                        {
                                          TAG: /* BuiltinV */3,
                                          _0: {
                                            printedRep: "builtinNot",
                                            bProc: not_
                                          }
                                        }
                                      ],
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: /* [] */0
};

function lambdaNamesToName(lambdaNames) {
  return List.map((function (symb) {
                switch (symb.TAG | 0) {
                  case /* SymbolC */1 :
                      return /* Name */{
                              _0: symb._0
                            };
                  case /* NumberC */0 :
                  case /* ListC */2 :
                      return Pervasives.failwith("Lambda parameter must be a symbol");
                  
                }
              }), lambdaNames);
}

function lstOfCondsToCondDatas(condDatas) {
  return List.map((function (condEntry) {
                switch (condEntry.TAG | 0) {
                  case /* NumberC */0 :
                  case /* SymbolC */1 :
                      return Pervasives.failwith("Invalid cond clause format");
                  case /* ListC */2 :
                      var match = condEntry._0;
                      if (!match) {
                        return Pervasives.failwith("Invalid cond clause format");
                      }
                      var match$1 = match.tl;
                      if (match$1 && !match$1.tl) {
                        return {
                                conditionExpr: parseExpression(match.hd),
                                resultExpr: parseExpression(match$1.hd)
                              };
                      } else {
                        return Pervasives.failwith("Invalid cond clause format");
                      }
                  
                }
              }), condDatas);
}

function processLetNames(myLetPairs) {
  return List.map((function (pair) {
                switch (pair.TAG | 0) {
                  case /* NumberC */0 :
                  case /* SymbolC */1 :
                      return Pervasives.failwith("Invalid let binding format");
                  case /* ListC */2 :
                      var match = pair._0;
                      if (!match) {
                        return Pervasives.failwith("Invalid let binding format");
                      }
                      var myName = match.hd;
                      switch (myName.TAG | 0) {
                        case /* SymbolC */1 :
                            var match$1 = match.tl;
                            if (match$1 && !match$1.tl) {
                              return {
                                      pairName: /* Name */{
                                        _0: myName._0
                                      },
                                      pairExpr: parseExpression(match$1.hd)
                                    };
                            } else {
                              return Pervasives.failwith("Invalid let binding format");
                            }
                        case /* NumberC */0 :
                        case /* ListC */2 :
                            return Pervasives.failwith("Invalid let binding format");
                        
                      }
                  
                }
              }), myLetPairs);
}

function parseExpression(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
        return {
                TAG: /* NumE */0,
                _0: input._0
              };
    case /* SymbolC */1 :
        var someVar = input._0;
        switch (someVar) {
          case "empty" :
              return /* EmptyE */0;
          case "false" :
              return {
                      TAG: /* BoolE */1,
                      _0: false
                    };
          case "true" :
              return {
                      TAG: /* BoolE */1,
                      _0: true
                    };
          default:
            return {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: someVar
                    }
                  };
        }
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("Syntax error");
        }
        var operator = match.hd;
        switch (operator.TAG | 0) {
          case /* SymbolC */1 :
              switch (operator._0) {
                case "and" :
                    var match$1 = match.tl;
                    if (match$1) {
                      var match$2 = match$1.tl;
                      if (match$2 && !match$2.tl) {
                        return {
                                TAG: /* AndE */3,
                                _0: parseExpression(match$1.hd),
                                _1: parseExpression(match$2.hd)
                              };
                      }
                      
                    }
                    break;
                case "cond" :
                    return {
                            TAG: /* CondE */6,
                            _0: lstOfCondsToCondDatas(match.tl)
                          };
                case "if" :
                    var match$3 = match.tl;
                    if (match$3) {
                      var match$4 = match$3.tl;
                      if (match$4) {
                        var match$5 = match$4.tl;
                        if (match$5 && !match$5.tl) {
                          return {
                                  TAG: /* IfE */5,
                                  _0: {
                                    boolExpr: parseExpression(match$3.hd),
                                    trueExpr: parseExpression(match$4.hd),
                                    falseExpr: parseExpression(match$5.hd)
                                  }
                                };
                        }
                        
                      }
                      
                    }
                    break;
                case "lambda" :
                    var match$6 = match.tl;
                    if (match$6) {
                      var names = match$6.hd;
                      switch (names.TAG | 0) {
                        case /* NumberC */0 :
                        case /* SymbolC */1 :
                            break;
                        case /* ListC */2 :
                            var match$7 = match$6.tl;
                            if (match$7 && !match$7.tl) {
                              return {
                                      TAG: /* LambdaE */7,
                                      _0: {
                                        nameList: lambdaNamesToName(names._0),
                                        lambdaBody: parseExpression(match$7.hd)
                                      }
                                    };
                            }
                            break;
                        
                      }
                    }
                    break;
                case "let" :
                    var match$8 = match.tl;
                    if (match$8) {
                      var myLetPairs = match$8.hd;
                      switch (myLetPairs.TAG | 0) {
                        case /* NumberC */0 :
                        case /* SymbolC */1 :
                            break;
                        case /* ListC */2 :
                            var match$9 = match$8.tl;
                            if (match$9 && !match$9.tl) {
                              return {
                                      TAG: /* LetE */8,
                                      _0: {
                                        letPairs: processLetNames(myLetPairs._0),
                                        letBody: parseExpression(match$9.hd)
                                      }
                                    };
                            }
                            break;
                        
                      }
                    }
                    break;
                case "or" :
                    var match$10 = match.tl;
                    if (match$10) {
                      var match$11 = match$10.tl;
                      if (match$11 && !match$11.tl) {
                        return {
                                TAG: /* OrE */4,
                                _0: parseExpression(match$10.hd),
                                _1: parseExpression(match$11.hd)
                              };
                      }
                      
                    }
                    break;
                default:
                  
              }
              break;
          case /* NumberC */0 :
          case /* ListC */2 :
              break;
          
        }
        return {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: parseExpression(operator),
                  tl: List.map(parseExpression, match.tl)
                }
              };
        break;
    
  }
}

function parseDefinition(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("Invalid definition format");
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("Invalid definition format");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 !== "define") {
                return Pervasives.failwith("Invalid definition format");
              }
              var match$2 = match.tl;
              if (!match$2) {
                return Pervasives.failwith("Invalid definition format");
              }
              var myName = match$2.hd;
              switch (myName.TAG | 0) {
                case /* SymbolC */1 :
                    var match$3 = match$2.tl;
                    if (match$3 && !match$3.tl) {
                      return [
                              /* Name */{
                                _0: myName._0
                              },
                              parseExpression(match$3.hd)
                            ];
                    } else {
                      return Pervasives.failwith("Invalid definition format");
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return Pervasives.failwith("Invalid definition format");
                
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("Invalid definition format");
          
        }
    
  }
}

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return {
                TAG: /* Expression */1,
                _0: parseExpression(input)
              };
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return {
                  TAG: /* Expression */1,
                  _0: parseExpression(input)
                };
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return {
                        TAG: /* Definition */0,
                        _0: parseDefinition(input)
                      };
              } else {
                return {
                        TAG: /* Expression */1,
                        _0: parseExpression(input)
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* Expression */1,
                      _0: parseExpression(input)
                    };
          
        }
    
  }
}

function parse(input) {
  return List.map(parsePiece, input);
}

function handleCond(tle, env, _myCondDatas) {
  while(true) {
    var myCondDatas = _myCondDatas;
    if (!myCondDatas) {
      return Pervasives.failwith("no conditions evaluated to true in a cond statement");
    }
    var match = myCondDatas.hd;
    var match$1 = $$eval(tle, env, match.conditionExpr);
    if (match$1.TAG !== /* BoolV */1) {
      return Pervasives.failwith("non-bool as condition in a cond statement");
    }
    if (match$1._0) {
      return $$eval(tle, env, match.resultExpr);
    }
    _myCondDatas = myCondDatas.tl;
    continue ;
  };
}

function $$eval(tle, _env, _expr) {
  while(true) {
    var expr = _expr;
    var env = _env;
    if (typeof expr === "number") {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
    switch (expr.TAG | 0) {
      case /* NumE */0 :
          return {
                  TAG: /* NumV */0,
                  _0: expr._0
                };
      case /* BoolE */1 :
          return {
                  TAG: /* BoolV */1,
                  _0: expr._0
                };
      case /* NameE */2 :
          var _tle = tle;
          var _env$1 = env;
          var targetName = expr._0;
          while(true) {
            var env$1 = _env$1;
            var tle$1 = _tle;
            if (env$1) {
              var match = List.find_opt((function(targetName){
                  return function (param) {
                    return Caml_obj.caml_equal(param[0], targetName);
                  }
                  }(targetName)), env$1.hd);
              if (match !== undefined) {
                return match[1];
              }
              _env$1 = env$1.tl;
              continue ;
            }
            if (!tle$1) {
              return Pervasives.failwith("Unbound name");
            }
            var match$1 = List.find_opt((function(targetName){
                return function (param) {
                  return Caml_obj.caml_equal(param[0], targetName);
                }
                }(targetName)), tle$1.hd);
            if (match$1 !== undefined) {
              return match$1[1];
            }
            _env$1 = /* [] */0;
            _tle = tle$1.tl;
            continue ;
          };
      case /* AndE */3 :
          var match$2 = $$eval(tle, env, expr._0);
          if (match$2.TAG !== /* BoolV */1) {
            return Pervasives.failwith("non booleans in an and statement");
          }
          if (!match$2._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: false
                  };
          }
          var b = $$eval(tle, env, expr._1);
          if (b.TAG === /* BoolV */1) {
            return {
                    TAG: /* BoolV */1,
                    _0: b._0
                  };
          } else {
            return Pervasives.failwith("non booleans in an and statement");
          }
      case /* OrE */4 :
          var match$3 = $$eval(tle, env, expr._0);
          if (match$3.TAG !== /* BoolV */1) {
            return Pervasives.failwith("non booleans in an or statement");
          }
          if (match$3._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: true
                  };
          }
          var b$1 = $$eval(tle, env, expr._1);
          if (b$1.TAG === /* BoolV */1) {
            return {
                    TAG: /* BoolV */1,
                    _0: b$1._0
                  };
          } else {
            return Pervasives.failwith("non booleans in an or statement");
          }
      case /* IfE */5 :
          var match$4 = expr._0;
          var match$5 = $$eval(tle, env, match$4.boolExpr);
          if (match$5.TAG !== /* BoolV */1) {
            return Pervasives.failwith("non booleans as first argument in an if statement");
          }
          if (match$5._0) {
            _expr = match$4.trueExpr;
            continue ;
          }
          _expr = match$4.falseExpr;
          continue ;
      case /* CondE */6 :
          return handleCond(tle, env, expr._0);
      case /* LambdaE */7 :
          var match$6 = expr._0;
          return {
                  TAG: /* ClosureV */4,
                  _0: {
                    cNameList: match$6.nameList,
                    cExpr: match$6.lambdaBody,
                    cEnv: env
                  }
                };
      case /* LetE */8 :
          var match$7 = expr._0;
          var newBindings = List.map((function(env){
              return function (param) {
                return [
                        param.pairName,
                        $$eval(tle, env, param.pairExpr)
                      ];
              }
              }(env)), match$7.letPairs);
          _expr = match$7.letBody;
          _env = {
            hd: newBindings,
            tl: env
          };
          continue ;
      case /* ApplicationE */9 :
          var match$8 = expr._0;
          if (!match$8) {
            return Pervasives.failwith("Cannot apply empty application");
          }
          var operatorValue = $$eval(tle, env, match$8.hd);
          var argValues = List.map((function(env){
              return function (param) {
                return $$eval(tle, env, param);
              }
              }(env)), match$8.tl);
          switch (operatorValue.TAG | 0) {
            case /* BuiltinV */3 :
                return Curry._1(operatorValue._0.bProc, argValues);
            case /* ClosureV */4 :
                var match$9 = operatorValue._0;
                var cNameList = match$9.cNameList;
                if (List.length(cNameList) !== List.length(argValues)) {
                  return Pervasives.failwith("Wrong number of arguments to function");
                }
                var newBindings$1 = List.combine(cNameList, argValues);
                _expr = match$9.cExpr;
                _env = {
                  hd: newBindings$1,
                  tl: match$9.cEnv
                };
                continue ;
            default:
              return Pervasives.failwith("Tried to apply non-function");
          }
      
    }
  };
}

function inBindingList(_alob, myName) {
  while(true) {
    var alob = _alob;
    if (!alob) {
      return false;
    }
    if (Caml_obj.caml_equal(alob.hd[0], myName)) {
      return true;
    }
    _alob = alob.tl;
    continue ;
  };
}

function inEnvironment(_env, myName) {
  while(true) {
    var env = _env;
    if (!env) {
      return false;
    }
    var bindingList1 = env.hd;
    if (!bindingList1 && !env.tl) {
      return false;
    }
    if (inBindingList(bindingList1, myName)) {
      return true;
    }
    _env = env.tl;
    continue ;
  };
}

function addDefinition(env, param) {
  var id = param[0];
  if (inEnvironment(env, id)) {
    return env;
  } else if (env) {
    return {
            hd: {
              hd: [
                id,
                $$eval(env, /* [] */0, param[1])
              ],
              tl: env.hd
            },
            tl: env.tl
          };
  } else {
    return Pervasives.failwith("Cannot add definition to empty environment");
  }
}

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: $$eval(tle, /* [] */0, d._0),
                tl: processHelper(tle, pieces.tl)
              };
      }
      var d$1 = d._0;
      _pieces = pieces.tl;
      _tle = addDefinition(tle, [
            d$1[0],
            d$1[1]
          ]);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

function stringOfValue(aValue) {
  switch (aValue.TAG | 0) {
    case /* NumV */0 :
        return String(aValue._0);
    case /* BoolV */1 :
        if (aValue._0) {
          return "#t";
        } else {
          return "#f";
        }
    case /* ListV */2 :
        var values = aValue._0;
        if (values) {
          return "[" + ($$String.concat(",", List.map(stringOfValue, values)) + "]");
        } else {
          return "empty";
        }
    case /* BuiltinV */3 :
        return aValue._0.printedRep;
    case /* ClosureV */4 :
        return "#<procedure>";
    
  }
}

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$Rackette.Reader.readAll(program))));
}

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parse empty expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("empty")), /* EmptyE */0, "read and parse empty expression");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* SymbolC */1,
            _0: "empty"
          })
    }, {
      TAG: /* Expression */1,
      _0: /* EmptyE */0
    }, "parse piece on empty");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("empty")), {
      TAG: /* Expression */1,
      _0: /* EmptyE */0
    }, "read and parse piece on empty");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, /* EmptyE */0)), "empty", "evaluation of empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("empty")))), "empty", "evaluation of empty list\nwith parse and read ");

exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.modulo = modulo;
exports.equalityq = equalityq;
exports.lessThanq = lessThanq;
exports.greaterThanq = greaterThanq;
exports.leqq = leqq;
exports.geqq = geqq;
exports.equalq = equalq;
exports.numberq = numberq;
exports.zeroq = zeroq;
exports.cons = cons;
exports.first = first;
exports.rest = rest;
exports.emptyq = emptyq;
exports.consq = consq;
exports.not_ = not_;
exports.initialTle = initialTle;
exports.lambdaNamesToName = lambdaNamesToName;
exports.lstOfCondsToCondDatas = lstOfCondsToCondDatas;
exports.processLetNames = processLetNames;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.handleCond = handleCond;
exports.$$eval = $$eval;
exports.inBindingList = inBindingList;
exports.inEnvironment = inEnvironment;
exports.addDefinition = addDefinition;
exports.$$process = $$process;
exports.stringOfValue = stringOfValue;
exports.rackette = rackette;
/*  Not a pure module */
